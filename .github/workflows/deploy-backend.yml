name: Deploy Backend to AWS ECS

on:
  push:
    branches: [main]
    paths: 
      - 'backend/**'
      - 'client.json'
  workflow_dispatch:
    inputs:
      run_migrations:
        description: 'Force run database migrations'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'true'
          - 'false'
      run_seed:
        description: 'Run database seed after deployment'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
  workflow_call:
    inputs:
      run_migrations:
        description: 'Force run database migrations'
        required: false
        default: 'auto'
        type: string
      run_seed:
        description: 'Run database seed after deployment'
        required: false
        default: 'false'
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection
        
      - name: Load client config
        id: config
        run: |
          echo "CLIENT=$(jq -r '.client_slug' client.json)" >> $GITHUB_OUTPUT
          echo "REGION=$(jq -r '.aws.region' client.json)" >> $GITHUB_OUTPUT
          echo "ACCOUNT=$(jq -r '.aws.account_id' client.json)" >> $GITHUB_OUTPUT
          echo "ECR_REPO=$(jq -r '.ecr.backend' client.json)" >> $GITHUB_OUTPUT
          echo "CLUSTER=$(jq -r '.ecs.cluster' client.json)" >> $GITHUB_OUTPUT
          echo "SERVICE=$(jq -r '.ecs.backend_service' client.json)" >> $GITHUB_OUTPUT
          echo "SECRETS_PREFIX=$(jq -r '.secrets_prefix' client.json)" >> $GITHUB_OUTPUT

      - name: Detect migration changes
        id: migration_check
        run: |
          # Check if prisma migrations folder has changes
          if git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^backend/prisma/migrations/'; then
            echo "migrations_changed=true" >> $GITHUB_OUTPUT
            echo "üóÑÔ∏è Database migrations detected in this commit"
          else
            echo "migrations_changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No database migration changes detected"
          fi
          
          # Check if prisma schema has changes
          if git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^backend/prisma/schema.prisma'; then
            echo "schema_changed=true" >> $GITHUB_OUTPUT
            echo "üìã Prisma schema changes detected"
          else
            echo "schema_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine if migrations should run
        id: should_migrate
        run: |
          MANUAL_OVERRIDE="${{ github.event.inputs.run_migrations }}"
          MIGRATIONS_CHANGED="${{ steps.migration_check.outputs.migrations_changed }}"
          
          if [ "$MANUAL_OVERRIDE" = "true" ]; then
            echo "run_migrations=true" >> $GITHUB_OUTPUT
            echo "üöÄ Migrations will run (manual override)"
          elif [ "$MANUAL_OVERRIDE" = "false" ]; then
            echo "run_migrations=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Migrations skipped (manual override)"
          elif [ "$MIGRATIONS_CHANGED" = "true" ]; then
            echo "run_migrations=true" >> $GITHUB_OUTPUT
            echo "üöÄ Migrations will run (changes detected)"
          else
            echo "run_migrations=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è No migrations needed (no changes detected)"
          fi
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ steps.config.outputs.REGION }}
          
      - name: Login to ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Build and push Docker image
        env:
          REGISTRY: ${{ steps.ecr.outputs.registry }}
          REPO: ${{ steps.config.outputs.ECR_REPO }}
          TAG: ${{ github.sha }}
        run: |
          echo "üî® Building backend Docker image..."
          cd backend
          docker build -t $REGISTRY/$REPO:$TAG -t $REGISTRY/$REPO:latest -f Dockerfile.prod .
          
          echo "üì§ Pushing to ECR..."
          docker push $REGISTRY/$REPO:$TAG
          docker push $REGISTRY/$REPO:latest
          echo "‚úÖ Image pushed: $REGISTRY/$REPO:$TAG"
          
      - name: Deploy to ECS
        id: deploy
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          SERVICE: ${{ steps.config.outputs.SERVICE }}
          REGISTRY: ${{ steps.ecr.outputs.registry }}
          REPO: ${{ steps.config.outputs.ECR_REPO }}
          TAG: ${{ github.sha }}
        run: |
          echo "üöÄ Deploying to ECS..."
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-services --cluster $CLUSTER --services $SERVICE --query 'services[0].taskDefinition' --output text)
          TASK_FAMILY=$(echo $TASK_DEF | cut -d'/' -f2 | cut -d':' -f1)
          
          echo "üìã Current task definition: $TASK_DEF"
          echo "üìã Task family: $TASK_FAMILY"
          
          # Get task definition JSON and update image
          aws ecs describe-task-definition --task-definition $TASK_FAMILY --query 'taskDefinition' > task-def.json
          
          # Update image in task definition - find the container by name "backend"
          NEW_IMAGE="$REGISTRY/$REPO:$TAG"
          echo "üîÑ Updating image to: $NEW_IMAGE"
          
          # Update the backend container image using jq (find by name)
          cat task-def.json | jq --arg IMAGE "$NEW_IMAGE" '
            .containerDefinitions = [.containerDefinitions[] | if .name == "backend" then .image = $IMAGE else . end] | 
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ' > new-task-def.json
          
          # Register new task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "‚úÖ New task definition registered: $NEW_TASK_DEF"
          
          # Update service with new task definition
          aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $NEW_TASK_DEF --force-new-deployment
          
          echo "‚è≥ Waiting for service to stabilize (timeout: 10 minutes)..."
          # Use a more resilient wait with retries
          MAX_ATTEMPTS=20
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "üìä Check $ATTEMPT/$MAX_ATTEMPTS..."
            
            # Check service status
            SERVICE_STATUS=$(aws ecs describe-services --cluster $CLUSTER --services $SERVICE \
              --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Deployments:length(deployments)}' \
              --output json)
            
            RUNNING=$(echo $SERVICE_STATUS | jq -r '.Running')
            DESIRED=$(echo $SERVICE_STATUS | jq -r '.Desired')
            DEPLOYMENTS=$(echo $SERVICE_STATUS | jq -r '.Deployments')
            STATUS=$(echo $SERVICE_STATUS | jq -r '.Status')
            
            echo "   Status: $STATUS, Running: $RUNNING/$DESIRED, Active deployments: $DEPLOYMENTS"
            
            # Success condition: 1 deployment, running equals desired, status is ACTIVE
            if [ "$STATUS" = "ACTIVE" ] && [ "$RUNNING" = "$DESIRED" ] && [ "$DEPLOYMENTS" = "1" ]; then
              echo "‚úÖ Service stabilized successfully!"
              break
            fi
            
            sleep 30
          done
          
          # Don't fail even if timeout - deployment may complete later
          echo "‚úÖ ECS deployment initiated"

      - name: Get running task for migrations
        id: get_task
        if: steps.should_migrate.outputs.run_migrations == 'true' || github.event.inputs.run_seed == 'true'
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          SERVICE: ${{ steps.config.outputs.SERVICE }}
        run: |
          echo "üîç Waiting for running task..."
          
          # ECS Fargate tasks can take 2-5 minutes to start
          # Retry for up to 5 minutes (15 attempts x 20 seconds)
          MAX_ATTEMPTS=15
          ATTEMPT=0
          TASK_ARN=""
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "üìä Attempt $ATTEMPT/$MAX_ATTEMPTS - Looking for running task..."
            
            TASK_ARN=$(aws ecs list-tasks \
              --cluster $CLUSTER \
              --service-name $SERVICE \
              --desired-status RUNNING \
              --query 'taskArns[0]' \
              --output text)
            
            if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
              # Verify task is actually in RUNNING state (not just PENDING)
              TASK_STATUS=$(aws ecs describe-tasks \
                --cluster $CLUSTER \
                --tasks $TASK_ARN \
                --query 'tasks[0].lastStatus' \
                --output text)
              
              if [ "$TASK_STATUS" = "RUNNING" ]; then
                echo "‚úÖ Found running task: $TASK_ARN"
                echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT
                exit 0
              else
                echo "   Task found but status is $TASK_STATUS, waiting..."
              fi
            else
              echo "   No running task found yet, waiting..."
            fi
            
            sleep 20
          done
          
          echo "‚ùå No running task found after $MAX_ATTEMPTS attempts"
          echo ""
          echo "üîç Debugging: Checking all recent tasks..."
          
          # List all tasks (including stopped) for debugging
          echo "All tasks in service:"
          aws ecs list-tasks --cluster $CLUSTER --service-name $SERVICE --query 'taskArns[]' --output text || true
          
          echo ""
          echo "Stopped tasks:"
          aws ecs list-tasks --cluster $CLUSTER --service-name $SERVICE --desired-status STOPPED --query 'taskArns[]' --output text || true
          
          echo ""
          echo "Service events (last 5):"
          aws ecs describe-services --cluster $CLUSTER --services $SERVICE \
            --query 'services[0].events[:5].[createdAt,message]' --output table || true
          
          echo ""
          echo "üí° Check CloudWatch logs for crash details: /ecs/creditxpress/backend"
          exit 1

      - name: Run database migrations
        if: steps.should_migrate.outputs.run_migrations == 'true'
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          TASK_ARN: ${{ steps.get_task.outputs.task_arn }}
        run: |
          echo "üóÑÔ∏è Running database migrations..."
          
          # Run prisma migrate deploy
          aws ecs execute-command \
            --cluster $CLUSTER \
            --task $TASK_ARN \
            --container backend \
            --interactive \
            --command "npx prisma migrate deploy" || {
              echo "‚ö†Ô∏è ECS Exec may not be enabled. Trying alternative approach..."
              echo "Please ensure ECS Exec is enabled on the service."
              exit 1
            }
          
          echo "‚úÖ Database migrations completed successfully"

      - name: Run database seed
        if: github.event.inputs.run_seed == 'true'
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          TASK_ARN: ${{ steps.get_task.outputs.task_arn }}
        run: |
          echo "üå± Running database seed..."
          
          aws ecs execute-command \
            --cluster $CLUSTER \
            --task $TASK_ARN \
            --container backend \
            --interactive \
            --command "npx prisma db seed"
          
          echo "‚úÖ Database seed completed successfully"

      - name: Deployment summary
        run: |
          echo "=========================================="
          echo "üìã BACKEND DEPLOYMENT SUMMARY"
          echo "=========================================="
          echo "Client: ${{ steps.config.outputs.CLIENT }}"
          echo "Region: ${{ steps.config.outputs.REGION }}"
          echo "Cluster: ${{ steps.config.outputs.CLUSTER }}"
          echo "Service: ${{ steps.config.outputs.SERVICE }}"
          echo "Image Tag: ${{ github.sha }}"
          echo "Migrations Run: ${{ steps.should_migrate.outputs.run_migrations }}"
          echo "Seed Run: ${{ github.event.inputs.run_seed || 'false' }}"
          echo "=========================================="
          echo "‚úÖ Backend deployment complete!"
