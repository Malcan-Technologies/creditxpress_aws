name: Deploy to Production

# Required GitHub Secrets:
# - SSH_KEYS: Private SSH key for server access
# - SSH_HOST: Server hostname/IP
# - SSH_USER: Server username
# - FRONTEND_ENV: Frontend environment variables (.env)
# - ADMIN_ENV: Admin environment variables (.env.local)
#   Must include: PORT, NODE_ENV, NEXT_PUBLIC_API_URL, NEXT_PUBLIC_SITE_URL
# - BACKEND_ENV: Backend environment variables (.env)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_full_deployment:
        description: 'Force full deployment (rebuild all components)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      deploy_frontend:
        description: 'Deploy frontend'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'true'
          - 'false'
      deploy_admin:
        description: 'Deploy admin'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'true'
          - 'false'
      deploy_backend:
        description: 'Deploy backend'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'true'
          - 'false'
      deploy_config:
        description: 'Deploy config'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'true'
          - 'false'

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KEYS }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
          eval $(ssh-agent -s)
          ssh-add ~/.ssh/deploy_key

      - name: Validate server connection
        run: |
          echo "Validating server connection..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'echo "Server connection successful"'

    #   - name: Deploy backend
    #     env:
    #       CTOS_B2B_PRIVATE_KEY: ${{ secrets.CTOS_B2B_PRIVATE_KEY }}
    #     run: |
    #       docker compose --env-file .env.backend -f docker-compose.prod.yml up -d --build

      - name: Setup environment files
        run: |
          # Create environment files from secrets
          echo "${{ secrets.FRONTEND_ENV }}" > frontend/.env
          echo "${{ secrets.ADMIN_ENV }}" > admin/.env.local
          echo "${{ secrets.BACKEND_ENV }}" > backend/.env

          # Add CTOS_B2B_PRIVATE_KEY to backend .env if it doesn't exist
          # Use heredoc to properly handle multi-line private key
          # The double quotes ensure the entire multi-line value is treated as a single string
          cat >> backend/.env << DEPLOY_CTOS_KEY_EOF
          CTOS_B2B_PRIVATE_KEY="${{ secrets.CTOS_B2B_PRIVATE_KEY }}"
          DEPLOY_CTOS_KEY_EOF

          # Make sure CORS_ALLOWED_ORIGINS is set in the backend .env file
          if ! grep -q "CORS_ALLOWED_ORIGINS" backend/.env; then
            echo "Adding CORS_ALLOWED_ORIGINS to backend/.env"
            echo "CORS_ALLOWED_ORIGINS=https://creditxpress.com.my,https://admin.creditxpress.com.my,https://api.creditxpress.com.my" >> backend/.env
          fi

      - name: Detect changes and determine deployment strategy
        id: changes
        run: |
          echo "üîç Determining deployment strategy..."
          
          # Check if this is a manual trigger with force full deployment
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ inputs.force_full_deployment }}" = "true" ]; then
            echo "üöÄ Manual trigger: Force full deployment requested"
            echo "frontend_changed=true" >> $GITHUB_OUTPUT
            echo "admin_changed=true" >> $GITHUB_OUTPUT
            echo "backend_changed=true" >> $GITHUB_OUTPUT
            echo "config_changed=true" >> $GITHUB_OUTPUT
            echo "deployment_reason=Manual full deployment" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "üéØ Manual trigger: Selective deployment"
            
            # Use manual selections or auto-detect
            if [ "${{ inputs.deploy_frontend }}" = "true" ]; then
              echo "frontend_changed=true" >> $GITHUB_OUTPUT
            elif [ "${{ inputs.deploy_frontend }}" = "false" ]; then
              echo "frontend_changed=false" >> $GITHUB_OUTPUT
            else
              # Auto-detect for frontend
              if git diff --name-only HEAD~1 HEAD | grep -E '^frontend/'; then
                echo "frontend_changed=true" >> $GITHUB_OUTPUT
              else
                echo "frontend_changed=false" >> $GITHUB_OUTPUT
              fi
            fi
            
            if [ "${{ inputs.deploy_admin }}" = "true" ]; then
              echo "admin_changed=true" >> $GITHUB_OUTPUT
            elif [ "${{ inputs.deploy_admin }}" = "false" ]; then
              echo "admin_changed=false" >> $GITHUB_OUTPUT
            else
              # Auto-detect for admin
              if git diff --name-only HEAD~1 HEAD | grep -E '^admin/'; then
                echo "admin_changed=true" >> $GITHUB_OUTPUT
              else
                echo "admin_changed=false" >> $GITHUB_OUTPUT
              fi
            fi
            
            if [ "${{ inputs.deploy_backend }}" = "true" ]; then
              echo "backend_changed=true" >> $GITHUB_OUTPUT
            elif [ "${{ inputs.deploy_backend }}" = "false" ]; then
              echo "backend_changed=false" >> $GITHUB_OUTPUT
            else
              # Auto-detect for backend
              if git diff --name-only HEAD~1 HEAD | grep -E '^backend/'; then
                echo "backend_changed=true" >> $GITHUB_OUTPUT
              else
                echo "backend_changed=false" >> $GITHUB_OUTPUT
              fi
            fi
            
            if [ "${{ inputs.deploy_config }}" = "true" ]; then
              echo "config_changed=true" >> $GITHUB_OUTPUT
            elif [ "${{ inputs.deploy_config }}" = "false" ]; then
              echo "config_changed=false" >> $GITHUB_OUTPUT
            else
              # Auto-detect for config and scripts
              if git diff --name-only HEAD~1 HEAD | grep -E '^config/|^scripts/'; then
                echo "config_changed=true" >> $GITHUB_OUTPUT
              else
                echo "config_changed=false" >> $GITHUB_OUTPUT
              fi
            fi
            
            echo "deployment_reason=Manual selective deployment" >> $GITHUB_OUTPUT
          else
            echo "üîÑ Automatic trigger: Change-based deployment"
            
            # Auto-detect changes for push events
            if git diff --name-only HEAD~1 HEAD | grep -E '^frontend/'; then
              echo "frontend_changed=true" >> $GITHUB_OUTPUT
            else
              echo "frontend_changed=false" >> $GITHUB_OUTPUT
            fi
            
            if git diff --name-only HEAD~1 HEAD | grep -E '^admin/'; then
              echo "admin_changed=true" >> $GITHUB_OUTPUT
            else
              echo "admin_changed=false" >> $GITHUB_OUTPUT
            fi
            
            if git diff --name-only HEAD~1 HEAD | grep -E '^backend/'; then
              echo "backend_changed=true" >> $GITHUB_OUTPUT
            else
              echo "backend_changed=false" >> $GITHUB_OUTPUT
            fi
            
            if git diff --name-only HEAD~1 HEAD | grep -E '^config/|^scripts/'; then
              echo "config_changed=true" >> $GITHUB_OUTPUT
            else
              echo "config_changed=false" >> $GITHUB_OUTPUT
            fi
            
            echo "deployment_reason=Automatic change-based deployment" >> $GITHUB_OUTPUT
          fi
          
          # Log the deployment plan
          echo "üìã Deployment Plan:"
          echo "- Reason: $(cat $GITHUB_OUTPUT | grep deployment_reason | cut -d'=' -f2)"
          echo "- Frontend: $(cat $GITHUB_OUTPUT | grep frontend_changed | cut -d'=' -f2)"
          echo "- Admin: $(cat $GITHUB_OUTPUT | grep admin_changed | cut -d'=' -f2)"
          echo "- Backend: $(cat $GITHUB_OUTPUT | grep backend_changed | cut -d'=' -f2)"
          echo "- Config: $(cat $GITHUB_OUTPUT | grep config_changed | cut -d'=' -f2)"

      - name: Deploy applications in parallel
        run: |
          echo "Starting parallel deployment..."
          
          # Create deployment scripts
          cat > deploy_frontend.sh << 'EOF'
          #!/bin/bash
          if [ "$1" = "true" ]; then
            echo "üöÄ Deploying frontend (changes detected)..."
            
            # Create destination directory and copy files
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'mkdir -p /var/www/growkapital/frontend'
            scp -i ~/.ssh/deploy_key frontend/.env ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/frontend/
            
            # Copy all frontend files
            rsync -avz --delete --exclude="node_modules" --exclude=".next/cache" \
              -e "ssh -i ~/.ssh/deploy_key" \
              frontend/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/frontend/
            
            # Build and start frontend
            ssh -i ~/.ssh/deploy_key -o ServerAliveInterval=60 -o ServerAliveCountMax=10 ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} '
              cd /var/www/growkapital/frontend
              
              # Stop and remove any existing frontend processes on port 3002
              echo "üßπ Cleaning up existing frontend processes..."
              pm2 stop frontend 2>/dev/null || true
              pm2 delete frontend 2>/dev/null || true
              pm2 stop growkapital-frontend 2>/dev/null || true
              pm2 delete growkapital-frontend 2>/dev/null || true
              
              # Kill any process using port 3002
              EXISTING_PID=$(lsof -ti:3002 || true)
              if [ ! -z "$EXISTING_PID" ]; then
                echo "Killing existing process on port 3002: $EXISTING_PID"
                kill -9 $EXISTING_PID 2>/dev/null || true
                sleep 2
              fi
              
              # Install pnpm if needed
              if ! command -v pnpm &> /dev/null; then
                echo "Installing pnpm..."
                npm install -g pnpm
              fi
              
              # Use cached node_modules if package.json has not changed
              if [ -f "package.json.deployed" ] && cmp -s package.json package.json.deployed; then
                echo "üì¶ Using cached dependencies (package.json unchanged)"
              else
                echo "üì¶ Installing fresh dependencies..."
                
                # Check disk space before installation
                AVAILABLE_SPACE=$(df /var/www/growkapital | awk "NR==2 {print \$4}")
                if [ "$AVAILABLE_SPACE" -lt 1048576 ]; then  # Less than 1GB
                  echo "‚ö†Ô∏è Low disk space detected. Cleaning up..."
                  
                  # Clean up space
                  docker system prune -f || true
                  npm cache clean --force || true
                  sudo rm -rf /tmp/* || true
                  
                  # Force clean old builds
                  sudo rm -rf .next || true
                  sudo rm -rf node_modules || true
                fi
                
                # Ensure directory exists and has correct permissions
                sudo mkdir -p /var/www/growkapital/frontend
                sudo chown -R $(whoami):$(whoami) /var/www/growkapital/frontend
                
                rm -rf node_modules
                rm -f pnpm-lock.yaml
                
                # Try installing with pnpm first
                if ! pnpm install; then
                  echo "PNPM install failed, trying with NPM..."
                  rm -rf node_modules
                  if ! npm install; then
                    echo "NPM install also failed. Checking disk space..."
                    df -h
                    echo "Installation error!"
                    exit 1
                  fi
                fi
                cp package.json package.json.deployed
              fi
              
              # Build frontend with optimizations
              echo "üî® Building frontend..."
              export NODE_OPTIONS="--max-old-space-size=4096"
              export NEXT_TELEMETRY_DISABLED=1
              export NEXT_PUBLIC_SKIP_BUILD_ERROR=1
              export GENERATE_SOURCEMAP=false
              
              # Run build and check for success
              BUILD_SUCCESS=false
              if timeout 400 pnpm run build:prod; then
                echo "‚úÖ Build completed successfully with pnpm"
                BUILD_SUCCESS=true
              else
                echo "‚ö†Ô∏è Build failed with pnpm. Trying with npx next build..."
                if timeout 400 npx next build --no-lint; then
                  echo "‚úÖ Build completed successfully with npx"
                  BUILD_SUCCESS=true
                else
                  echo "‚ùå Build failed with both pnpm and npx"
                  BUILD_SUCCESS=false
                fi
              fi
              
              # Start the frontend service
              if [ "$BUILD_SUCCESS" = "true" ]; then
                echo "‚ñ∂Ô∏è Starting frontend service..."
                pm2 start npm --name "frontend" -- start -- --port 3002 --hostname 0.0.0.0
                pm2 save
                echo "‚úÖ Frontend service started as 'frontend'"
              else
                echo "‚ùå Build failed - cannot start frontend service"
                exit 1
              fi
            '
            echo "‚úÖ Frontend deployment completed"
          else
            echo "‚è≠Ô∏è Skipping frontend deployment (no changes detected)"
          fi
          EOF
          
          cat > deploy_admin.sh << 'EOF'
          #!/bin/bash
          if [ "$1" = "true" ]; then
            echo "üöÄ Deploying admin (changes detected)..."
            
            # Create destination directory and copy files
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'mkdir -p /var/www/growkapital/admin'
            scp -i ~/.ssh/deploy_key admin/.env.local ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/admin/
            
            # Copy all admin files
            rsync -avz --delete --exclude="node_modules" --exclude=".next/cache" \
              -e "ssh -i ~/.ssh/deploy_key" \
              admin/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/admin/
            
            # Make deployment script executable
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'chmod +x /var/www/growkapital/admin/deploy-admin.sh'
            
            # Build and start admin
            ssh -i ~/.ssh/deploy_key -o ServerAliveInterval=60 -o ServerAliveCountMax=10 ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} '
              cd /var/www/growkapital/admin
              
              # Stop and remove any existing admin processes on port 3003
              echo "üßπ Cleaning up existing admin processes..."
              pm2 stop admin 2>/dev/null || true
              pm2 delete admin 2>/dev/null || true
              pm2 stop growkapital-admin 2>/dev/null || true
              pm2 delete growkapital-admin 2>/dev/null || true
              
              # Kill any process using port 3003
              EXISTING_PID=$(lsof -ti:3003 || true)
              if [ ! -z "$EXISTING_PID" ]; then
                echo "Killing existing process on port 3003: $EXISTING_PID"
                kill -9 $EXISTING_PID 2>/dev/null || true
                sleep 2
              fi
              
              # Install pnpm if needed
              if ! command -v pnpm &> /dev/null; then
                echo "Installing pnpm..."
                npm install -g pnpm
              fi
              
              # Use cached node_modules if package.json has not changed
              if [ -f "package.json.deployed" ] && cmp -s package.json package.json.deployed; then
                echo "üì¶ Using cached dependencies (package.json unchanged)"
              else
                echo "üì¶ Installing fresh dependencies..."
                
                # Check disk space before installation
                AVAILABLE_SPACE=$(df /var/www/growkapital | awk "NR==2 {print \$4}")
                if [ "$AVAILABLE_SPACE" -lt 1048576 ]; then  # Less than 1GB
                  echo "‚ö†Ô∏è Low disk space detected. Cleaning up..."
                  
                  # Clean up space
                  docker system prune -f || true
                  npm cache clean --force || true
                  sudo rm -rf /tmp/* || true
                  
                  # Force clean old builds
                  sudo rm -rf .next || true
                  sudo rm -rf node_modules || true
                fi
                
                # Ensure directory exists and has correct permissions
                sudo mkdir -p /var/www/growkapital/admin
                sudo chown -R $(whoami):$(whoami) /var/www/growkapital/admin
                
                rm -rf node_modules
                rm -f pnpm-lock.yaml
                
                # Try installing with pnpm first
                if ! pnpm install; then
                  echo "PNPM install failed, trying with NPM..."
                  rm -rf node_modules
                  if ! npm install; then
                    echo "NPM install also failed. Checking disk space..."
                    df -h
                    echo "Installation error!"
                    exit 1
                  fi
                fi
                cp package.json package.json.deployed
              fi
              
              # Verify admin environment setup
              echo "üîç Verifying admin environment setup..."
              if [ ! -f ".env.local" ]; then
                echo "‚ùå .env.local file not found for admin"
                exit 1
              fi
              echo "‚úÖ Admin environment verified"
              
              # Build admin with optimizations
              echo "üî® Building admin..."
              export NODE_OPTIONS="--max-old-space-size=4096"
              export NEXT_TELEMETRY_DISABLED=1
              export NEXT_PUBLIC_SKIP_BUILD_ERROR=1
              export GENERATE_SOURCEMAP=false
              
              # Run build and check for success
              BUILD_SUCCESS=false
              if timeout 400 pnpm run build:prod; then
                echo "‚úÖ Build completed successfully with pnpm"
                BUILD_SUCCESS=true
              else
                echo "‚ö†Ô∏è Build failed with pnpm. Trying with npx next build..."
                if timeout 400 npx next build --no-lint; then
                  echo "‚úÖ Build completed successfully with npx"
                  BUILD_SUCCESS=true
                else
                  echo "‚ùå Build failed with both pnpm and npx"
                  BUILD_SUCCESS=false
                fi
              fi
              
              # Copy public files to standalone build directory
              if [ "$BUILD_SUCCESS" = "true" ] && [ -d ".next/standalone" ]; then
                echo "üìÅ Copying public files to standalone build..."
                mkdir -p .next/standalone/public
                if [ -d "public" ] && [ "$(ls -A public)" ]; then
                  cp -r public/* .next/standalone/public/ 2>/dev/null || echo "No files to copy from public directory"
                  echo "‚úÖ Public files copied to standalone build"
                else
                  echo "‚ö†Ô∏è No public directory or files found"
                fi
              fi
              
              # Start the admin service
              if [ "$BUILD_SUCCESS" = "true" ]; then
                echo "‚ñ∂Ô∏è Starting admin service..."
                # Use npm start for consistency (standalone can cause issues)
                pm2 start npm --name "admin" -- start -- --port 3003 --hostname 0.0.0.0
                pm2 save
                echo "‚úÖ Admin service started as 'admin'"
              else
                echo "‚ùå Build failed - cannot start admin service"
                exit 1
              fi
            '
            echo "‚úÖ Admin deployment completed"
          else
            echo "‚è≠Ô∏è Skipping admin deployment (no changes detected)"
          fi
          EOF
          
          cat > deploy_backend.sh << 'EOF'
          #!/bin/bash
          if [ "$1" = "true" ]; then
            echo "üöÄ Deploying backend (changes detected)..."
            
            # Create destination directory and copy files
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'mkdir -p /var/www/growkapital/backend'
            scp -i ~/.ssh/deploy_key backend/.env ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/backend/
            
            # Ensure CORS_ALLOWED_ORIGINS is set on the server
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} '
              if ! grep -q "CORS_ALLOWED_ORIGINS" /var/www/growkapital/backend/.env; then
                echo "Adding CORS_ALLOWED_ORIGINS to backend .env on server"
                echo "CORS_ALLOWED_ORIGINS=https://creditxpress.com.my,https://admin.creditxpress.com.my,https://api.creditxpress.com.my" >> /var/www/growkapital/backend/.env
              fi
            '
            
            # Copy all backend files
            rsync -avz --delete --exclude="node_modules" --exclude="dist" \
              -e "ssh -i ~/.ssh/deploy_key" \
              backend/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/backend/
            
            # Copy scripts directory to the root of the project
            rsync -avz --delete \
              -e "ssh -i ~/.ssh/deploy_key" \
              scripts/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/scripts/
            
            # Make scripts executable
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'chmod +x /var/www/growkapital/scripts/*.sh'
            
            # Build and start backend containers with optimizations
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} '
              cd /var/www/growkapital/backend
              
              # Stop existing containers
              docker compose -f docker-compose.prod.yml down || true
              
              # Build with cache and start containers
              echo "üî® Building backend containers with cache..."
              export DOCKER_BUILDKIT=1
              export COMPOSE_DOCKER_CLI_BUILD=1
              
              # Stop and remove existing containers to avoid name conflicts
              echo "üõë Stopping existing backend containers..."
              docker compose -f docker-compose.prod.yml down || true
              
              # Ensure containers are fully removed if compose down fails
              echo "üßπ Ensuring clean container state..."
              docker stop backend-backend-1 backend-postgres-1 2>/dev/null || true
              docker rm backend-backend-1 backend-postgres-1 2>/dev/null || true
              
              # Pre-pull base images to avoid Docker Hub rate limit issues during build
              echo "üì• Pre-pulling base images..."
              docker pull node:20-alpine 2>/dev/null || echo "‚ö†Ô∏è Could not pull node:20-alpine (using cached version)"
              docker pull postgres:16-alpine 2>/dev/null || echo "‚ö†Ô∏è Could not pull postgres:16-alpine (using cached version)"
              
              if ! docker compose -f docker-compose.prod.yml up -d --build; then
                echo "‚ùå Backend build failed. Checking for Prisma client issues..."
                
                # Try to fix Prisma client issues and rebuild
                echo "üîß Attempting to fix Prisma client issues..."
                docker compose -f docker-compose.prod.yml exec backend npm run prisma:fix || true
                
                echo "üîÑ Retrying backend build..."
                # Stop containers again before retry
                docker compose -f docker-compose.prod.yml down || true
                docker stop backend-backend-1 backend-postgres-1 2>/dev/null || true
                docker rm backend-backend-1 backend-postgres-1 2>/dev/null || true
                if ! docker compose -f docker-compose.prod.yml up -d --build; then
                  echo "‚ùå Backend build failed again. Showing logs:"
                  docker compose -f docker-compose.prod.yml logs backend
                  exit 1
                fi
              fi
              
              echo "‚úÖ Backend containers started successfully"
              
              # Quick Prisma client verification (reduced timeout)
              echo "üîç Quick Prisma client verification..."
              if ! timeout 30 docker compose -f docker-compose.prod.yml exec backend npm run prisma:verify; then
                echo "‚ö†Ô∏è Prisma client verification failed. Attempting fix..."
                docker compose -f docker-compose.prod.yml exec backend npm run prisma:fix
                docker compose -f docker-compose.prod.yml restart backend
              fi
              
              echo "‚úÖ Prisma client verified successfully"
              
              # Check if containers are actually running
              echo "üîç Checking container status..."
              docker compose -f docker-compose.prod.yml ps
              
              # Wait for backend to be ready
              echo "‚è≥ Waiting for backend to be ready..."
              MAX_WAIT=60
              WAIT_COUNT=0
              while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
                if docker compose -f docker-compose.prod.yml exec backend wget --quiet --tries=1 --spider http://localhost:4001/api/health; then
                  echo "‚úÖ Backend is ready"
                  break
                fi
                sleep 2
                WAIT_COUNT=$((WAIT_COUNT + 2))
                if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
                  echo "‚ùå Backend failed to start within $MAX_WAIT seconds"
                  echo "Container logs:"
                  docker compose -f docker-compose.prod.yml logs backend --tail 50
                  exit 1
                fi
              done
              
              # Run database migrations
              echo "üóÑÔ∏è Running database migrations..."
              if [ -f "./scripts/run-migrations.sh" ]; then
                chmod +x ./scripts/run-migrations.sh
                ./scripts/run-migrations.sh
              else
                echo "‚ö†Ô∏è Migration script not found, running migrations directly..."
                docker compose -f docker-compose.prod.yml exec backend npx prisma migrate deploy
              fi
              
              # Run database seed to ensure default settings exist
              echo "üå± Running database seed to ensure default settings..."
              docker compose -f docker-compose.prod.yml exec backend npx prisma db seed
              
              # Ensure receipts and uploads directories exist with proper permissions
              echo "üìÅ Setting up receipts and uploads directories..."
              docker compose -f docker-compose.prod.yml exec backend mkdir -p receipts
              docker compose -f docker-compose.prod.yml exec backend chmod 777 receipts
              docker compose -f docker-compose.prod.yml exec backend mkdir -p uploads/default-letters
              docker compose -f docker-compose.prod.yml exec backend chmod 777 uploads/default-letters
              docker compose -f docker-compose.prod.yml exec backend mkdir -p uploads/disbursement-slips
              docker compose -f docker-compose.prod.yml exec backend chmod 777 uploads/disbursement-slips
              docker compose -f docker-compose.prod.yml exec backend mkdir -p uploads/stamp-certificates
              docker compose -f docker-compose.prod.yml exec backend chmod 777 uploads/stamp-certificates
              docker compose -f docker-compose.prod.yml exec backend mkdir -p uploads/kyc
              docker compose -f docker-compose.prod.yml exec backend chmod 777 uploads/kyc
              docker compose -f docker-compose.prod.yml exec backend mkdir -p uploads/stamped-agreements
              docker compose -f docker-compose.prod.yml exec backend chmod 777 uploads/stamped-agreements
              
              # ReactPDF dependencies are handled in Dockerfile - skipping verification
              
              # Test receipt generation functionality
              echo "üßæ Testing receipt generation functionality..."
              if docker compose -f docker-compose.prod.yml exec backend node -e "
                try {
                  console.log('Testing Prisma client...');
                  const { prisma } = require('./dist/src/lib/prisma');
                  console.log('‚úÖ Prisma client loaded');
                  
                  console.log('Testing Receipt service...');
                  const ReceiptService = require('./dist/src/lib/receiptService');
                  console.log('‚úÖ Receipt service loaded');
                  
                  console.log('Testing ReactPDF template...');
                  const receiptTemplate = require('./dist/src/lib/receiptTemplate');
                  console.log('‚úÖ Receipt template loaded');
                  
                  console.log('‚úÖ All receipt components loaded successfully');
                  process.exit(0);
                } catch (error) {
                  console.log('‚ùå Receipt component test failed:', error.message);
                  console.log('Stack:', error.stack);
                  process.exit(1);
                }
              "; then
                echo "‚úÖ Receipt service test passed"
              else
                echo "‚ö†Ô∏è Receipt service test failed, checking build artifacts..."
                docker compose -f docker-compose.prod.yml exec backend ls -la dist/src/lib/
                echo "Continuing deployment despite test failure..."
              fi
              
              # Cron jobs are now handled by node-cron within the application
              echo "‚úÖ Cron jobs are now built into the application using node-cron"
              
              # Final verification that containers are running
              echo "üîç Final container status check..."
              docker compose -f docker-compose.prod.yml ps
              
              # Verify backend is still responsive
              if docker compose -f docker-compose.prod.yml exec backend wget --quiet --tries=1 --spider http://localhost:4001/api/health; then
                echo "‚úÖ Backend is healthy and ready"
              else
                echo "‚ùå Backend health check failed at end of deployment"
                docker compose -f docker-compose.prod.yml logs backend --tail 20
                exit 1
              fi
            '
            echo "‚úÖ Backend deployment completed"
          else
            echo "‚è≠Ô∏è Skipping backend deployment (no changes detected)"
          fi
          EOF
          
          # Make scripts executable
          chmod +x deploy_frontend.sh deploy_admin.sh deploy_backend.sh
          
          # Run deployments in parallel
          ./deploy_frontend.sh "${{ steps.changes.outputs.frontend_changed }}" &
          FRONTEND_PID=$!
          
          ./deploy_admin.sh "${{ steps.changes.outputs.admin_changed }}" &
          ADMIN_PID=$!
          
          ./deploy_backend.sh "${{ steps.changes.outputs.backend_changed }}" &
          BACKEND_PID=$!
          
          # Wait for all deployments to complete
          echo "‚è≥ Waiting for parallel deployments to complete..."
          wait $FRONTEND_PID
          FRONTEND_EXIT=$?
          
          wait $ADMIN_PID
          ADMIN_EXIT=$?
          
          wait $BACKEND_PID
          BACKEND_EXIT=$?
          
          # Check if any deployment failed
          if [ $FRONTEND_EXIT -ne 0 ] || [ $ADMIN_EXIT -ne 0 ] || [ $BACKEND_EXIT -ne 0 ]; then
            echo "‚ùå One or more deployments failed"
            echo "Frontend exit code: $FRONTEND_EXIT"
            echo "Admin exit code: $ADMIN_EXIT"
            echo "Backend exit code: $BACKEND_EXIT"
            exit 1
          fi
          
          echo "üéâ All parallel deployments completed successfully"

      - name: Deploy config files and scripts
        if: steps.changes.outputs.config_changed == 'true'
        run: |
          echo "üöÄ Deploying config files and scripts (changes detected)..."
          
          # Create destination directory and copy files
          ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'mkdir -p /var/www/growkapital/config'
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key" \
            config/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/config/
          
          # Also copy scripts directory when config changes (they often work together)
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key" \
            scripts/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/var/www/growkapital/scripts/
          
          # Make scripts executable
          ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'chmod +x /var/www/growkapital/scripts/*.sh'
          
          # Apply nginx configuration
          ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} '
            echo "üìã Copying nginx configuration..."
            sudo cp /var/www/growkapital/config/nginx.conf /etc/nginx/sites-enabled/creditxpress.conf
            
            # Test nginx configuration
            echo "üß™ Testing nginx configuration..."
            if ! sudo nginx -t; then
              echo "‚ùå Nginx configuration test failed. Showing error:"
              sudo nginx -t
              exit 1
            fi
            
            # Reload nginx
            echo "üîÑ Reloading nginx..."
            if ! sudo systemctl reload nginx; then
              echo "‚ùå Nginx reload failed. Showing status:"
              sudo systemctl status nginx
              exit 1
            fi
            
            echo "‚úÖ Nginx configuration applied successfully"
          '

      - name: Skip config and scripts deployment
        if: steps.changes.outputs.config_changed == 'false'
        run: echo "‚è≠Ô∏è Skipping config and scripts deployment (no changes detected)"

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} '
            # Quick verification with reduced timeouts
            
            # Check frontend (if deployed)
            if [ "${{ steps.changes.outputs.frontend_changed }}" = "true" ]; then
              echo "üîç Verifying frontend..."
              if timeout 10 curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:3002/ | grep -q "200"; then
                echo "‚úÖ Frontend is accessible"
              else
                echo "‚ö†Ô∏è Frontend verification failed"
                pm2 logs frontend --lines 5 --nostream
              fi
            fi
            
            # Check admin (if deployed)
            if [ "${{ steps.changes.outputs.admin_changed }}" = "true" ]; then
              echo "üîç Verifying admin..."
              # Give admin more time to start up
              sleep 5
              if timeout 15 curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:3003/login | grep -q "200"; then
                echo "‚úÖ Admin is accessible"
              else
                echo "‚ö†Ô∏è Admin verification failed, checking PM2 status..."
                pm2 show admin || echo "Admin process not found in PM2"
                pm2 logs admin --lines 10 --nostream || echo "No logs available"
              fi
            fi
            
            # Check backend (if deployed)
            if [ "${{ steps.changes.outputs.backend_changed }}" = "true" ]; then
              echo "üîç Verifying backend..."
              
              # Quick container check
              if ! docker ps | grep -q "backend-backend-1"; then
                echo "‚ùå Backend container is not running"
                docker logs backend-backend-1 --tail 10
                exit 1
              fi
              
              echo "‚úÖ Backend container is running"
              
              # Quick health check (reduced retries)
              MAX_RETRIES=3
              RETRY_COUNT=0
              BACKEND_OK=false
              
              while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$BACKEND_OK" = "false" ]; do
                if [ $RETRY_COUNT -gt 0 ]; then
                  echo "Retry $RETRY_COUNT of $MAX_RETRIES..."
                  sleep 5
                fi
                
                if timeout 10 curl -s https://creditxpress.com.my/api/health | grep -q "ok"; then
                  BACKEND_OK=true
                  echo "‚úÖ Backend is accessible"
                else
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                fi
              done
              
              if [ "$BACKEND_OK" = "false" ]; then
                echo "‚ö†Ô∏è Backend health check failed after $MAX_RETRIES attempts"
                docker logs backend-backend-1 --tail 20
                echo "‚ö†Ô∏è Continuing deployment (container is running)..."
              fi
            fi
            
            # Check nginx configuration (if config changed)
            if [ "${{ steps.changes.outputs.config_changed }}" = "true" ]; then
              echo "üîç Checking nginx configuration..."
              sudo nginx -t
              
              # Reload nginx if needed
              if [ -f "/tmp/nginx-reload-needed" ]; then
                echo "üîÑ Reloading nginx..."
                sudo systemctl reload nginx
                rm -f "/tmp/nginx-reload-needed"
              fi
            fi
            
            echo "üéâ Deployment verification completed"
          ' 